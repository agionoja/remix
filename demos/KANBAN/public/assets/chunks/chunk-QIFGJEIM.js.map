{
  "version": 3,
  "sources": ["../../../../../packages/fetch-router/src/lib/request-methods.ts", "../../../../../packages/route-pattern/src/lib/split.ts", "../../../../../packages/route-pattern/src/lib/search-constraints.ts", "../../../../../packages/route-pattern/src/lib/parse.ts", "../../../../../packages/route-pattern/src/lib/href.ts", "../../../../../packages/route-pattern/src/lib/stringify.ts", "../../../../../packages/route-pattern/src/lib/join.ts", "../../../../../packages/route-pattern/src/lib/route-pattern.ts", "../../../../../packages/fetch-router/src/lib/route-map.ts", "../../../../../packages/fetch-router/src/lib/route-helpers/method.ts", "../../../../../packages/fetch-router/src/lib/route-helpers/form.ts", "../../../../../packages/fetch-router/src/lib/route-helpers/resources.ts", "../../../routes.ts", "../../../../../node_modules/.pnpm/@remix-run+dom@0.0.0-experimental-remix-jam.6/node_modules/@remix-run/dom/src/jsx-runtime.ts"],
  "sourcesContent": ["export type RequestBodyMethod = 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS'\n\n/**\n * All HTTP request methods for requests that may have a body.\n */\nexport const RequestBodyMethods = ['POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'] as const\n\nexport type RequestMethod = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS'\n\n/**\n * All HTTP request methods that are supported by the router.\n */\nexport const RequestMethods = ['GET', 'HEAD', ...RequestBodyMethods] as const\n", "type Range = [number, number] // [start (inclusive), end (exclusive)]\n\nexport interface SplitResult {\n  protocol: Range | undefined\n  hostname: Range | undefined\n  port: Range | undefined\n  pathname: Range | undefined\n  search: Range | undefined\n}\n\n/**\n * Split a route pattern into protocol, hostname, port, pathname, and search\n * ranges. Ranges are [start (inclusive), end (exclusive)].\n */\nexport function split<T extends string>(source: T): SplitResult {\n  let protocol: Range | undefined\n  let hostname: Range | undefined\n  let port: Range | undefined\n  let pathname: Range | undefined\n  let search: Range | undefined\n\n  // search\n  let searchStart = source.indexOf('?')\n  if (searchStart !== -1) {\n    search = [searchStart + 1, source.length]\n    source = source.slice(0, searchStart) as T\n  }\n\n  let index = 0\n  let solidusIndex = source.indexOf('://')\n  if (solidusIndex !== -1) {\n    // protocol\n    if (solidusIndex !== 0) {\n      protocol = [0, solidusIndex]\n    }\n    index = solidusIndex + 3\n\n    // hostname + port\n    let hostEndIndex = source.indexOf('/', index)\n    if (hostEndIndex === -1) hostEndIndex = source.length\n\n    // detect port (numeric) at end of host segment\n    let colonIndex = source.lastIndexOf(':', hostEndIndex - 1)\n    if (colonIndex !== -1 && colonIndex >= index) {\n      // Ensure everything after the colon is digits\n      let isPort = true\n      for (let i = colonIndex + 1; i < hostEndIndex; i++) {\n        let char = source.charCodeAt(i)\n        if (char < 48 /* '0' */ || char > 57 /* '9' */) {\n          isPort = false\n          break\n        }\n      }\n\n      if (isPort && colonIndex + 1 < hostEndIndex) {\n        // hostname up to colon, port after colon\n        hostname = [index, colonIndex]\n        port = [colonIndex + 1, hostEndIndex]\n      } else {\n        hostname = [index, hostEndIndex]\n      }\n    } else {\n      hostname = [index, hostEndIndex]\n    }\n\n    index = hostEndIndex === source.length ? hostEndIndex : hostEndIndex + 1\n  }\n\n  // pathname\n  if (index !== source.length) {\n    if (source.charAt(index) === '/') {\n      index += 1\n    }\n\n    pathname = [index, source.length]\n  }\n\n  return { protocol, hostname, port, pathname, search }\n}\n\nexport interface SplitPattern {\n  protocol: string | undefined\n  hostname: string | undefined\n  port: string | undefined\n  pathname: string | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Split<T extends string> =\n  _Split<T> extends infer S extends Partial<SplitPattern> ? {\n    protocol: S['protocol'] extends string ? S['protocol'] : undefined\n    hostname: S['hostname'] extends string ? S['hostname'] : undefined\n    port: S['port'] extends string ? S['port'] : undefined\n    pathname: S['pathname'] extends string ? S['pathname'] : undefined\n    search: S['search'] extends string ? S['search'] : undefined\n  } :\n  never\n\n// prettier-ignore\ntype _Split<T extends string> =\n  T extends '' ? {} :\n  T extends `${infer L}?${infer R}` ? _Split<L> & { search: R } :\n  T extends `${infer Protocol}://${infer R}` ?\n    Protocol extends '' ? (\n      R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { pathname: Pathname } :\n      SplitHost<R>\n    ) :\n    Protocol extends `${string}/${string}` ? { pathname: T } :\n    R extends `${infer Host}/${infer Pathname}` ? SplitHost<Host> & { protocol: Protocol; pathname: Pathname } :\n    SplitHost<R> & { protocol: Protocol } :\n  T extends `/${infer Pathname}` ? { pathname: Pathname } :\n  { pathname: T }\n\n// prettier-ignore\ntype SplitHost<T extends string> =\n  T extends `${infer L}:${infer R}` ?\n    IsDigits<R> extends true ? { hostname: L; port: R} :\n    SplitHost<R> extends { hostname: infer H extends string; port: infer P extends string } ? { hostname: `${L}:${H}`; port: P } :\n    { hostname: T } :\n  { hostname: T }\n\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\n// prettier-ignore\ntype IsDigits<S extends string> =\n  S extends `${_0_9}${infer T}` ?\n    T extends '' ? true :\n    IsDigits<T> :\n  false\n", "export type SearchConstraints = Map<\n  string,\n  { requiredValues?: Set<string>; requireAssignment: boolean; allowBare: boolean }\n>\n\nexport function parseSearchConstraints(search: string): SearchConstraints {\n  let constraints: SearchConstraints = new Map()\n\n  for (let part of search.split('&')) {\n    if (part === '') continue\n    let eqIndex = part.indexOf('=')\n    if (eqIndex === -1) {\n      // Presence-only (no '=')\n      let name = decodeSearchComponent(part)\n      let existing = constraints.get(name)\n      if (!existing) {\n        constraints.set(name, { requireAssignment: false, allowBare: true })\n      }\n      continue\n    }\n\n    let name = decodeSearchComponent(part.slice(0, eqIndex))\n    let valuePart = part.slice(eqIndex + 1)\n    let existing = constraints.get(name)\n    if (!existing) {\n      existing = { requireAssignment: true, allowBare: false }\n      constraints.set(name, existing)\n    } else {\n      existing.requireAssignment = true\n      existing.allowBare = false\n    }\n\n    if (valuePart.length > 0) {\n      let decodedValue = decodeSearchComponent(valuePart)\n      if (!existing.requiredValues) existing.requiredValues = new Set<string>()\n      existing.requiredValues.add(decodedValue)\n    }\n  }\n\n  return constraints\n}\n\nexport function parseSearch(search: string): {\n  namesWithoutAssignment: Set<string>\n  namesWithAssignment: Set<string>\n  valuesByKey: Map<string, Set<string>>\n} {\n  if (search.startsWith('?')) search = search.slice(1)\n\n  let namesWithoutAssignment = new Set<string>(),\n    namesWithAssignment = new Set<string>(),\n    valuesByKey = new Map<string, Set<string>>()\n\n  if (search.length > 0) {\n    for (let part of search.split('&')) {\n      if (part === '') continue\n      let eqIndex = part.indexOf('=')\n      if (eqIndex === -1) {\n        let name = decodeSearchComponent(part)\n        namesWithoutAssignment.add(name)\n        continue\n      }\n\n      let name = decodeSearchComponent(part.slice(0, eqIndex))\n      let valuePart = part.slice(eqIndex + 1)\n      namesWithAssignment.add(name)\n      let value = decodeSearchComponent(valuePart)\n      let set = valuesByKey.get(name) ?? new Set<string>()\n      if (!valuesByKey.has(name)) valuesByKey.set(name, set)\n      set.add(value)\n    }\n  }\n\n  return { namesWithoutAssignment, namesWithAssignment, valuesByKey }\n}\n\nfunction decodeSearchComponent(text: string): string {\n  try {\n    return decodeURIComponent(text.replace(/\\+/g, ' '))\n  } catch {\n    return text\n  }\n}\n", "import { split, type SplitPattern, type Split } from './split.ts'\nimport { parseSearchConstraints, type SearchConstraints } from './search-constraints.ts'\nimport type { ForceDistributive } from './type-utils.ts'\n\n/**\n * An error thrown when a pattern fails to parse.\n */\nexport class ParseError extends Error {\n  /**\n   * The source pattern that failed to parse.\n   */\n  source: string\n  /**\n   * The position in the source where the error occurred.\n   */\n  position: number\n  /**\n   * The name of the part being parsed (e.g., \"pathname\", \"hostname\").\n   */\n  partName: string\n\n  /**\n   * @param description A description of the error\n   * @param partName The name of the part being parsed\n   * @param source The source pattern\n   * @param position The position in the source where the error occurred\n   */\n  constructor(description: string, partName: string, source: string, position: number) {\n    super(`${description} in ${partName}`)\n    this.name = 'ParseError'\n    this.source = source\n    this.position = position\n    this.partName = partName\n  }\n}\n\nexport interface ParseResult {\n  protocol: Array<Token> | undefined\n  hostname: Array<Token> | undefined\n  port: string | undefined\n  pathname: Array<Token> | undefined\n  search: string | undefined\n  searchConstraints: SearchConstraints | undefined\n}\n\nexport function parse<T extends string>(source: T): ParseResult {\n  let protocol: Token[] | undefined\n  let hostname: Token[] | undefined\n  let port: string | undefined\n  let pathname: Token[] | undefined\n  let search: string | undefined\n  let searchConstraints: SearchConstraints | undefined\n\n  let ranges = split(source)\n\n  if (ranges.protocol) {\n    protocol = parsePart('protocol', '', source, ...ranges.protocol)\n  }\n  if (ranges.hostname) {\n    hostname = parsePart('hostname', '.', source, ...ranges.hostname)\n  }\n  if (ranges.port) {\n    port = source.slice(...ranges.port)\n  }\n  if (ranges.pathname) {\n    pathname = parsePart('pathname', '/', source, ...ranges.pathname)\n  }\n  if (ranges.search) {\n    search = source.slice(...ranges.search)\n    searchConstraints = parseSearchConstraints(search)\n  }\n\n  return { protocol, hostname, port, pathname, search, searchConstraints }\n}\n\nconst identifierMatcher = /^[a-zA-Z_$][a-zA-Z_$0-9]*/\n\nfunction parsePart(partName: string, sep: string, source: string, start: number, end: number) {\n  let tokens: Token[] = []\n  let currentTokens = tokens\n  // Use a simple stack of token arrays: the top is where new tokens are appended.\n  // The root of the stack is the `part` array. Each '(' pushes a new array; ')'\n  // pops and wraps it in an optional token which is appended to the new top.\n  let tokensStack: Array<Token[]> = [tokens]\n  let openIndexes: Array<number> = []\n\n  let appendText = (text: string) => {\n    let lastToken = currentTokens.at(-1)\n    if (lastToken?.type === 'text') {\n      lastToken.value += text\n    } else {\n      currentTokens.push({ type: 'text', value: text })\n    }\n  }\n\n  let i = start\n  while (i < end) {\n    let char = source[i]\n\n    // separator\n    if (char === sep) {\n      currentTokens.push({ type: 'separator' })\n      i += 1\n      continue\n    }\n\n    // variable\n    if (char === ':') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (!name) throw new ParseError('missing variable name', partName, source, i)\n      currentTokens.push({ type: 'variable', name })\n      i += name.length\n      continue\n    }\n\n    // wildcard\n    if (char === '*') {\n      i += 1\n      let remaining = source.slice(i, end)\n      let name = identifierMatcher.exec(remaining)?.[0]\n      if (name) {\n        currentTokens.push({ type: 'wildcard', name })\n        i += name.length\n      } else {\n        currentTokens.push({ type: 'wildcard' })\n      }\n      continue\n    }\n\n    // optional\n    if (char === '(') {\n      tokensStack.push((currentTokens = []))\n      openIndexes.push(i)\n      i += 1\n      continue\n    }\n    if (char === ')') {\n      if (tokensStack.length === 1) throw new ParseError('unmatched )', partName, source, i)\n      let tokens = tokensStack.pop()!\n      currentTokens = tokensStack[tokensStack.length - 1]\n      currentTokens.push({ type: 'optional', tokens })\n      openIndexes.pop()\n      i += 1\n      continue\n    }\n\n    // text\n    if (char === '\\\\') {\n      let next = source.at(i + 1)\n      if (!next || i + 1 >= end) throw new ParseError('dangling escape', partName, source, i)\n      appendText(next)\n      i += 2\n      continue\n    }\n\n    appendText(char)\n    i += 1\n  }\n\n  if (openIndexes.length > 0) {\n    // Report the position of the earliest unmatched '('\n    throw new ParseError('unmatched (', partName, source, openIndexes[0])\n  }\n\n  return tokens\n}\n\nexport interface ParsedPattern {\n  protocol: Token[] | undefined\n  hostname: Token[] | undefined\n  port: string | undefined\n  pathname: Token[] | undefined\n  search: string | undefined\n}\n\n// prettier-ignore\nexport type Parse<T extends string> =\n  T extends ForceDistributive ?\n    Split<T> extends infer S extends SplitPattern ?\n      {\n        protocol: S['protocol'] extends string ? ParsePart<S['protocol']> : undefined\n        hostname: S['hostname'] extends string ? ParsePart<S['hostname'], '.'> : undefined\n        port: S['port'] extends string ? S['port'] : undefined\n        pathname: S['pathname'] extends string ? ParsePart<S['pathname'], '/'> : undefined\n        search: S['search'] extends string ? S['search'] : undefined\n      } :\n      never :\n    never\n\nexport type Variable = { type: 'variable'; name: string }\nexport type Wildcard = { type: 'wildcard'; name?: string }\nexport type Text = { type: 'text'; value: string }\nexport type Separator = { type: 'separator' }\nexport type Optional = { type: 'optional'; tokens: Token[] }\n\nexport type Token = Variable | Wildcard | Text | Separator | Optional\n\ntype ParsePartState = {\n  tokens: Token[]\n  optionals: Array<Token[]>\n  rest: string\n}\n\ntype ParsePart<T extends string, Sep extends string = ''> = _ParsePart<\n  {\n    tokens: []\n    optionals: []\n    rest: T\n  },\n  Sep\n>\n\n// prettier-ignore\ntype _ParsePart<S extends ParsePartState, Sep extends string = ''> =\n  S extends { rest: `${infer Head}${infer Tail}` } ?\n    Head extends Sep ? _ParsePart<AppendToken<S, { type: 'separator' }, Tail>, Sep> :\n    Head extends ':' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        (name extends '' ? never : _ParsePart<AppendToken<S, { type: 'variable', name: name }, rest>, Sep>) :\n      never : // this should never happen\n    Head extends '*' ?\n      IdentifierParse<Tail> extends { identifier: infer name extends string, rest: infer rest extends string } ?\n        _ParsePart<AppendToken<S, (name extends '' ? { type: 'wildcard' } : { type: 'wildcard', name: name }), rest>, Sep> :\n      never : // this should never happen\n    Head extends '(' ? _ParsePart<PushOptional<S, Tail>, Sep> :\n    Head extends ')' ?\n      PopOptional<S, Tail> extends infer next extends ParsePartState ? _ParsePart<next, Sep> :\n      never : // unmatched `)` handled in PopOptional\n    Head extends '\\\\' ?\n      Tail extends `${infer L}${infer R}` ? _ParsePart<AppendText<S, L, R>, Sep> :\n      never : // dangling escape\n    _ParsePart<AppendText<S, Head, Tail>, Sep> :\n  S['optionals'] extends [] ? S['tokens'] :\n  never // unmatched `(`\n\n// prettier-ignore\ntype AppendToken<S extends ParsePartState, token extends Token, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    {\n      tokens: S['tokens']\n      optionals: [...O, [...Top, token]]\n      rest: rest\n    } :\n    {\n      tokens: [...S['tokens'], token]\n      optionals: S['optionals']\n      rest: rest;\n    }\n\n// prettier-ignore\ntype AppendText<S extends ParsePartState, text extends string, rest extends string> =\n  S['optionals'] extends [...infer O extends Array<Token[]>, infer Top extends Token[]] ?\n    (\n      Top extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: S['tokens']; optionals: [...O, [...Tokens, { type: 'text', value: `${value}${text}` }]]; rest: rest } :\n        { tokens: S['tokens']; optionals: [...O, [...Top, { type: 'text', value: text }]]; rest: rest }\n    ) :\n    (\n      S['tokens'] extends [...infer Tokens extends Array<Token>, { type: 'text', value: infer value extends string }] ?\n        { tokens: [...Tokens, { type: 'text', value: `${value}${text}` }]; optionals: S['optionals']; rest: rest } :\n        { tokens: [...S['tokens'], { type: 'text', value: text }]; optionals: S['optionals']; rest: rest }\n    )\n\n// Optional stack helpers ---------------------------------------------------------------------------\n\ntype PushOptional<S extends ParsePartState, rest extends string> = {\n  tokens: S['tokens']\n  optionals: [...S['optionals'], []]\n  rest: rest\n}\n\n// If stack is empty -> unmatched ')', return never\n// Else pop and wrap tokens into an Optional token; append to parent or part\ntype PopOptional<S extends ParsePartState, R extends string> = S['optionals'] extends [\n  ...infer O extends Array<Token[]>,\n  infer Top extends Array<Token>,\n]\n  ? O extends [...infer OO extends Array<Token[]>, infer Parent extends Token[]]\n    ? {\n        tokens: S['tokens']\n        optionals: [...OO, [...Parent, { type: 'optional'; tokens: Top }]]\n        rest: R\n      }\n    : { tokens: [...S['tokens'], { type: 'optional'; tokens: Top }]; optionals: []; rest: R }\n  : never\n\n// Identifier --------------------------------------------------------------------------------------\n\n// prettier-ignore\ntype _a_z = 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'\ntype _A_Z = Uppercase<_a_z>\ntype _0_9 = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'\n\ntype IdentifierHead = _a_z | _A_Z | '_' | '$'\ntype IdentifierTail = IdentifierHead | _0_9\n\ntype IdentifierParse<T extends string> = _IdentifierParse<{ identifier: ''; rest: T }>\n\n// prettier-ignore\ntype _IdentifierParse<S extends { identifier: string, rest: string }> =\n  S extends { identifier: '', rest: `${infer Head extends IdentifierHead}${infer Tail}` } ?\n    _IdentifierParse<{ identifier: Head, rest: Tail }> :\n    S extends { identifier: string, rest: `${infer Head extends IdentifierTail}${infer Tail}`} ?\n      _IdentifierParse<{ identifier: `${S['identifier']}${Head}`, rest: Tail }> :\n      S\n", "import type { RequiredParams, OptionalParams } from './params.ts'\nimport { parse, type ParseResult, type Token } from './parse.ts'\nimport type { RoutePattern } from './route-pattern.ts'\nimport type { UnknownArgs } from './type-utils.ts'\nimport type { Variant } from './variant.ts'\n\n/**\n * An error thrown when a required parameter is missing when building an href.\n */\nexport class MissingParamError extends Error {\n  /**\n   * The name of the missing parameter.\n   */\n  readonly paramName: string\n\n  /**\n   * @param paramName The name of the missing parameter\n   */\n  constructor(paramName: string) {\n    super(`Missing required parameter: ${paramName}`)\n    this.name = 'MissingParamError'\n    this.paramName = paramName\n  }\n}\n\n/**\n * Create a reusable href builder function.\n *\n * @returns A function that builds hrefs from patterns and parameters\n */\nexport function createHrefBuilder<T extends string | RoutePattern = string>(): HrefBuilder<T> {\n  return (pattern: string | RoutePattern, ...args: UnknownArgs) =>\n    formatHref(parse(typeof pattern === 'string' ? pattern : pattern.source), ...args)\n}\n\nexport function formatHref(\n  parsed: ParseResult,\n  params?: Record<string, any>,\n  searchParams?: Record<string, any>,\n): string {\n  params = params ?? {}\n\n  let href = ''\n\n  if (parsed.hostname != null) {\n    // Default protocol is https because it's free these days so there's no\n    // excuse not to use it.\n    let protocol = parsed.protocol != null ? resolveTokens(parsed.protocol, '', params) : 'https'\n    let hostname = resolveTokens(parsed.hostname, '.', params)\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    href += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = resolveTokens(parsed.pathname, '/', params)\n    href += pathname.startsWith('/') ? pathname : `/${pathname}`\n  } else {\n    href += '/'\n  }\n\n  if (searchParams) {\n    let urlSearchParams: URLSearchParams\n    if (\n      typeof searchParams === 'object' &&\n      !Array.isArray(searchParams) &&\n      !(searchParams instanceof URLSearchParams)\n    ) {\n      let filteredParams: Record<string, string> = {}\n      for (let key in searchParams) {\n        let value = searchParams[key]\n        if (value != null) {\n          filteredParams[key] = String(value)\n        }\n      }\n      urlSearchParams = new URLSearchParams(filteredParams)\n    } else {\n      urlSearchParams = new URLSearchParams(searchParams)\n    }\n\n    let search = urlSearchParams.toString()\n    if (search !== '') {\n      href += `?${search}`\n    }\n  } else if (parsed.search) {\n    href += `?${parsed.search}`\n  }\n\n  return href\n}\n\nfunction resolveTokens(tokens: Token[], sep: string, params: Record<string, any>): string {\n  let str = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable' || token.type === 'wildcard') {\n      let name = token.name ?? '*'\n      if (params[name] == null) throw new MissingParamError(name)\n      str += String(params[name])\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      try {\n        str += resolveTokens(token.tokens, sep, params)\n      } catch (error) {\n        if (!(error instanceof MissingParamError)) {\n          throw error\n        }\n\n        // Missing required parameter, ok to skip since it's optional\n      }\n    }\n  }\n\n  return str\n}\n\n/**\n * A function that builds hrefs from patterns and parameters.\n */\nexport interface HrefBuilder<T extends string | RoutePattern = string> {\n  /**\n   * @param pattern The pattern to build an href for\n   * @param args The parameters and optional search params\n   * @returns The built href\n   */\n  <P extends string extends T ? string : SourceOf<T> | Variant<SourceOf<T>>>(\n    pattern: P | RoutePattern<P>,\n    ...args: HrefBuilderArgs<P>\n  ): string\n}\n\n// prettier-ignore\ntype SourceOf<T> =\n  T extends string ? T :\n  T extends RoutePattern<infer S extends string> ? S :\n  never\n\n/**\n * The arguments for a `href()` function.\n */\n// prettier-ignore\nexport type HrefBuilderArgs<T extends string> =\n  [RequiredParams<T>] extends [never] ?\n    [] | [null | undefined | Record<string, any>] | [null | undefined | Record<string, any>, HrefSearchParams] :\n    [HrefParams<T>, HrefSearchParams] | [HrefParams<T>]\n\n// prettier-ignore\ntype HrefParams<T extends string> =\n  Record<RequiredParams<T>, ParamValue> &\n  Partial<Record<OptionalParams<T>, ParamValue | null | undefined>>\n\ntype HrefSearchParams =\n  | NonNullable<ConstructorParameters<typeof URLSearchParams>[0]>\n  | Record<string, ParamValue | undefined | null>\n\ntype ParamValue = string | number | bigint | boolean\n", "import type { Token, ParseResult, ParsedPattern } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\n\nexport function stringify(parsed: Partial<ParseResult>): string {\n  let str = ''\n\n  if (parsed.hostname != null) {\n    let protocol = parsed.protocol != null ? stringifyTokens(parsed.protocol) : ''\n    let hostname = parsed.hostname != null ? stringifyTokens(parsed.hostname, '.') : ''\n    let port = parsed.port != null ? `:${parsed.port}` : ''\n    str += `${protocol}://${hostname}${port}`\n  }\n\n  if (parsed.pathname != null) {\n    let pathname = stringifyTokens(parsed.pathname, '/')\n    str += startsWithSeparator(parsed.pathname) ? pathname : `/${pathname}`\n  } else {\n    str += '/'\n  }\n\n  if (parsed.search) {\n    str += `?${parsed.search}`\n  } else if (parsed.searchConstraints != null) {\n    let search = stringifySearchConstraints(parsed.searchConstraints)\n    if (search !== '') {\n      str += `?${search}`\n    }\n  }\n\n  return str\n}\n\nexport function startsWithSeparator(tokens: Token[]): boolean {\n  if (tokens.length === 0) return false\n\n  let firstToken = tokens[0]\n  if (firstToken.type === 'separator') return true\n\n  // Check if it starts with an optional that contains a separator\n  if (firstToken.type === 'optional' && firstToken.tokens && firstToken.tokens.length > 0) {\n    return startsWithSeparator(firstToken.tokens)\n  }\n\n  return false\n}\n\nexport function stringifyTokens(tokens: Token[], sep = ''): string {\n  let str = ''\n\n  for (let i = 0; i < tokens.length; i++) {\n    let token = tokens[i]\n    if (token.type === 'variable') {\n      str += `:${token.name}`\n    } else if (token.type === 'wildcard') {\n      str += `*${token.name ?? ''}`\n    } else if (token.type === 'text') {\n      str += token.value\n    } else if (token.type === 'separator') {\n      str += sep\n    } else if (token.type === 'optional') {\n      str += `(${stringifyTokens(token.tokens, sep)})`\n    }\n  }\n\n  return str\n}\n\nexport function stringifySearchConstraints(search: SearchConstraints): string {\n  let parts: string[] = []\n\n  for (let [key, value] of search.entries()) {\n    if (value.allowBare && !value.requireAssignment) {\n      // Parameter can appear without assignment (e.g., just \"debug\")\n      parts.push(key)\n    } else if (value.requiredValues && value.requiredValues.size > 0) {\n      // Parameter has specific required values - create separate entries for each value\n      for (let requiredValue of value.requiredValues) {\n        parts.push(`${key}=${requiredValue}`)\n      }\n    } else if (value.requireAssignment) {\n      // Parameter requires assignment but no specific values\n      parts.push(`${key}=`)\n    }\n  }\n\n  return parts.join('&')\n}\n\n// prettier-ignore\nexport type Stringify<T extends ParsedPattern> =\n  T['hostname'] extends Token[] ?\n    `${StringifyTokens<T['protocol'], ''>}://${StringifyTokens<T['hostname'], '.'>}${StringifyPort<T['port']>}${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}` :\n    `${StringifyPathname<T['pathname']>}${StringifySearch<T['search']>}`\n\n// prettier-ignore\ntype StringifyTokens<T extends Token[] | undefined, Sep extends string> =\n  T extends undefined ? '' :\n  T extends [] ? '' :\n  T extends [infer Head extends Token, ...infer Tail extends Token[]] ?\n    `${StringifyToken<Head, Sep>}${StringifyTokens<Tail, Sep>}` :\n    never\n\n// prettier-ignore\ntype StringifyToken<T extends Token, Sep extends string> =\n  T extends { type: 'text', value: infer V extends string } ? V :\n  T extends { type: 'variable', name: infer N extends string } ? `:${N}` :\n  T extends { type: 'wildcard', name: infer N extends string } ? `*${N}` :\n  T extends { type: 'wildcard' } ? '*' :\n  T extends { type: 'separator' } ? Sep :\n  T extends { type: 'optional', tokens: infer Tokens extends Token[] } ? `(${StringifyTokens<Tokens, Sep>})` :\n  never\n\n// prettier-ignore\ntype StringifyPathname<T extends Token[] | undefined> =\n  T extends undefined ? '/' :\n  T extends [] ? '/' :\n  T extends Token[] ?\n    StartsWithSeparator<T> extends true ?\n      `${StringifyTokens<T, '/'>}` :\n      `/${StringifyTokens<T, '/'>}` :\n    never\n\ntype StringifyPort<T extends string | undefined> = T extends string ? `:${T}` : ''\n\ntype StringifySearch<T extends string | undefined> = T extends string ? `?${T}` : ''\n\n// prettier-ignore\nexport type StartsWithSeparator<T extends Token[]> =\n  T extends [] ? false :\n  T extends [{ type: 'separator' }, ...Token[]] ? true :\n  T extends [{ type: 'optional', tokens: infer Tokens extends Token[] }, ...Token[]] ?\n    StartsWithSeparator<Tokens> :\n    false\n", "import type { Parse, ParsedPattern, ParseResult, Separator, Token } from './parse.ts'\nimport type { SearchConstraints } from './search-constraints.ts'\nimport { stringify, startsWithSeparator } from './stringify.ts'\nimport type { Stringify, StartsWithSeparator } from './stringify.ts'\n\nexport function join(a: ParseResult, b: ParseResult): string {\n  let { protocol, hostname, port } = b.hostname != null ? b : a\n  let pathname = joinPathnames(a.pathname, b.pathname)\n  let searchConstraints = joinSearchConstraints(a.searchConstraints, b.searchConstraints)\n\n  return stringify({\n    protocol,\n    hostname,\n    port,\n    pathname,\n    searchConstraints,\n  })\n}\n\nfunction joinPathnames(a: Token[] | undefined, b: Token[] | undefined): Token[] | undefined {\n  if (b == null || b.length === 0) return a\n  if (a == null || a.length === 0) return b\n\n  let tokens = [...a]\n\n  // Remove trailing separator from base if present\n  if (tokens.length > 0 && tokens[tokens.length - 1].type === 'separator') {\n    tokens.pop()\n  }\n\n  // Check if input starts with a separator (including inside optionals)\n  let inputStartsWithSeparator = startsWithSeparator(b)\n\n  // If input is exactly a single separator, there is nothing to append.\n  // This avoids creating a trailing slash like \"/hello/\" when joining with base '/'.\n  if (b.length === 1 && b[0].type === 'separator') {\n    return tokens\n  }\n\n  // Only add separator between base and input if input doesn't start with one\n  if (!inputStartsWithSeparator) {\n    tokens.push({ type: 'separator' })\n  }\n\n  // Add input pathname\n  tokens.push(...b)\n\n  return tokens\n}\n\nfunction joinSearchConstraints(\n  baseSearch: SearchConstraints | undefined,\n  inputSearch: SearchConstraints | undefined,\n): SearchConstraints | undefined {\n  if (inputSearch == null) return baseSearch\n  if (baseSearch == null) return inputSearch\n\n  // Merge the two search constraint maps\n  let merged = new Map(baseSearch)\n\n  for (let [key, inputConstraint] of inputSearch.entries()) {\n    let baseConstraint = merged.get(key)\n    if (baseConstraint == null) {\n      merged.set(key, inputConstraint)\n    } else {\n      // Merge constraints for the same key\n      let mergedConstraint = {\n        requireAssignment: baseConstraint.requireAssignment || inputConstraint.requireAssignment,\n        allowBare: baseConstraint.allowBare && inputConstraint.allowBare,\n        requiredValues: undefined as Set<string> | undefined,\n      }\n\n      // Merge required values\n      if (baseConstraint.requiredValues || inputConstraint.requiredValues) {\n        mergedConstraint.requiredValues = new Set([\n          ...(baseConstraint.requiredValues || []),\n          ...(inputConstraint.requiredValues || []),\n        ])\n      }\n\n      merged.set(key, mergedConstraint)\n    }\n  }\n\n  return merged\n}\n\n/**\n * Join two pattern strings together.\n */\nexport type Join<A extends string, B extends string> = _Join<Parse<A>, Parse<B>>\n\ntype _Join<A extends ParsedPattern, B extends ParsedPattern> = Stringify<{\n  protocol: JoinOriginField<A, B, 'protocol'>\n  hostname: JoinOriginField<A, B, 'hostname'>\n  port: JoinOriginField<A, B, 'port'>\n  pathname: JoinPathnames<A['pathname'], B['pathname']>\n  search: JoinSearch<A['search'], B['search']>\n}>\n\n// prettier-ignore\ntype JoinOriginField<\n  A extends ParsedPattern,\n  B extends ParsedPattern,\n  Field extends 'protocol' | 'hostname' | 'port'\n> = B['hostname'] extends Token[] ? B[Field] : A[Field]\n\n// prettier-ignore\ntype JoinPathnames<A extends Token[] | undefined, B extends Token[] | undefined> =\n  B extends undefined ? A :\n  B extends [] ? A :\n  A extends undefined ? B :\n  A extends [] ? B :\n  A extends Token[] ?\n    B extends Token[] ? JoinPathnameTokens<RemoveTrailingSeparator<A>, B> :\n    never :\n  never\n\n// prettier-ignore\ntype RemoveTrailingSeparator<T extends Token[]> =\n  T extends [...infer Rest extends Token[], Separator] ? Rest : T\n\n// prettier-ignore\ntype JoinPathnameTokens<\n  A extends Token[],\n  B extends Token[]\n> = B extends [Separator] ?\n    A :\n    StartsWithSeparator<B> extends true ?\n      [...A, ...B] :\n      [...A, Separator, ...B]\n\n// prettier-ignore\ntype JoinSearch<\n  A extends string | undefined,\n  B extends string | undefined\n> = B extends undefined ? A :\n    A extends undefined ? B :\n    `${A}&${B}`\n", "import { formatHref, type HrefBuilderArgs } from './href.ts'\nimport { join, type Join } from './join.ts'\nimport type { Params } from './params.ts'\nimport { parse, type Token, type ParseResult } from './parse.ts'\nimport { parseSearch, type SearchConstraints } from './search-constraints.ts'\n\nexport interface RoutePatternOptions {\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  ignoreCase?: boolean\n}\n\n/**\n * A pattern for matching URLs.\n */\nexport class RoutePattern<T extends string = string> {\n  /**\n   * The source string that was used to create this pattern.\n   */\n  readonly source: T\n  /**\n   * Whether to ignore case when matching URL pathnames.\n   */\n  readonly ignoreCase: boolean\n\n  #parsed: ParseResult\n  #compiled: CompileResult | undefined\n\n  /**\n   * @param source The source pattern string or another `RoutePattern` to copy\n   * @param options Options for the pattern\n   */\n  constructor(source: T | RoutePattern<T>, options?: RoutePatternOptions) {\n    this.source = typeof source === 'string' ? source : source.source\n    this.ignoreCase = options?.ignoreCase === true\n    this.#parsed = parse(this.source)\n  }\n\n  /**\n   * Generate a href (URL) for this pattern.\n   *\n   * @param args The parameters and optional search params\n   * @returns The href\n   */\n  href(...args: HrefBuilderArgs<T>): string {\n    return formatHref(this.#parsed, ...(args as any))\n  }\n\n  /**\n   * Join this pattern with another pattern. This is useful when building a pattern relative to a\n   * base pattern.\n   *\n   * Note: The returned pattern will use the same options as this pattern.\n   *\n   * @param input The pattern to join with\n   * @returns The joined pattern\n   */\n  join<P extends string>(input: P | RoutePattern<P>): RoutePattern<Join<T, P>> {\n    let parsedInput = parse(typeof input === 'string' ? input : input.source)\n    return new RoutePattern(join(this.#parsed, parsedInput) as Join<T, P>, {\n      ignoreCase: this.ignoreCase,\n    })\n  }\n\n  /**\n   * Match a URL against this pattern.\n   *\n   * @param url The URL to match\n   * @returns The match result, or `null` if the URL doesn't match\n   */\n  match(url: URL | string): RouteMatch<T> | null {\n    if (typeof url === 'string') url = new URL(url)\n\n    let { matchOrigin, matcher, paramNames } = this.#compile()\n\n    let pathname = this.ignoreCase ? url.pathname.toLowerCase() : url.pathname\n    let match = matcher.exec(matchOrigin ? `${url.origin}${pathname}` : pathname)\n    if (match === null) return null\n\n    // Map positional capture groups to parameter names in source order\n    let params = {} as any\n    for (let i = 0; i < paramNames.length; i++) {\n      let paramName = paramNames[i]\n      params[paramName] = match[i + 1]\n    }\n\n    if (\n      this.#parsed.searchConstraints != null &&\n      !matchSearch(url.search, this.#parsed.searchConstraints)\n    ) {\n      return null\n    }\n\n    return { url, params }\n  }\n\n  #compile(): CompileResult {\n    if (this.#compiled) return this.#compiled\n    this.#compiled = compilePattern(this.#parsed, this.ignoreCase)\n    return this.#compiled\n  }\n\n  /**\n   * Test if a URL matches this pattern.\n   *\n   * @param url The URL to test\n   * @returns `true` if the URL matches this pattern, `false` otherwise\n   */\n  test(url: URL | string): boolean {\n    return this.match(url) !== null\n  }\n\n  toString() {\n    return this.source\n  }\n}\n\nexport interface RouteMatch<T extends string> {\n  /**\n   * The parameters that were extracted from the URL protocol, hostname, and/or pathname.\n   */\n  readonly params: Params<T>\n  /**\n   * The URL that was matched.\n   */\n  readonly url: URL\n}\n\ninterface CompileResult {\n  matchOrigin: boolean\n  matcher: RegExp\n  paramNames: string[]\n}\n\nfunction compilePattern(parsed: ParseResult, ignoreCase: boolean): CompileResult {\n  let { protocol, hostname, port, pathname } = parsed\n\n  let matchOrigin = hostname !== undefined\n  let matcher: RegExp\n  let paramNames: string[] = []\n\n  if (matchOrigin) {\n    let protocolSource = protocol\n      ? tokensToRegExpSource(protocol, '', '.*', paramNames, true)\n      : '[^:]+'\n    let hostnameSource = hostname\n      ? tokensToRegExpSource(hostname, '.', '[^.]+?', paramNames, true)\n      : '[^/:]+'\n    let portSource = port !== undefined ? `:${regexpEscape(port)}` : '(?::[0-9]+)?'\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^${protocolSource}://${hostnameSource}${portSource}/${pathnameSource}$`)\n  } else {\n    let pathnameSource = pathname\n      ? tokensToRegExpSource(pathname, '/', '[^/]+?', paramNames, ignoreCase)\n      : ''\n\n    matcher = new RegExp(`^/${pathnameSource}$`)\n  }\n\n  return { matchOrigin, matcher, paramNames }\n}\n\nfunction tokensToRegExpSource(\n  tokens: Token[],\n  sep: string,\n  paramRegExpSource: string,\n  paramNames: string[],\n  forceLowerCase: boolean,\n): string {\n  let source = ''\n\n  for (let token of tokens) {\n    if (token.type === 'variable') {\n      paramNames.push(token.name)\n      source += `(${paramRegExpSource})`\n    } else if (token.type === 'wildcard') {\n      if (token.name) {\n        paramNames.push(token.name)\n        source += `(.*)`\n      } else {\n        source += `(?:.*)`\n      }\n    } else if (token.type === 'text') {\n      source += regexpEscape(forceLowerCase ? token.value.toLowerCase() : token.value)\n    } else if (token.type === 'separator') {\n      source += regexpEscape(sep)\n    } else if (token.type === 'optional') {\n      source += `(?:${tokensToRegExpSource(token.tokens, sep, paramRegExpSource, paramNames, forceLowerCase)})?`\n    }\n  }\n\n  return source\n}\n\nfunction regexpEscape(text: string): string {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction matchSearch(search: string, constraints: SearchConstraints): boolean {\n  let { namesWithoutAssignment, namesWithAssignment, valuesByKey } = parseSearch(search)\n\n  for (let [key, constraint] of constraints) {\n    let hasAssigned = namesWithAssignment.has(key),\n      hasBare = namesWithoutAssignment.has(key),\n      values = valuesByKey.get(key)\n\n    if (constraint.requiredValues && constraint.requiredValues.size > 0) {\n      if (!values) return false\n      for (let value of constraint.requiredValues) {\n        if (!values.has(value)) return false\n      }\n      continue\n    }\n\n    if (constraint.requireAssignment) {\n      if (!hasAssigned) return false\n      continue\n    }\n\n    if (!(hasAssigned || hasBare)) return false\n  }\n\n  return true\n}\n", "import { RoutePattern } from '@remix-run/route-pattern'\nimport type { HrefBuilderArgs, Join, RouteMatch } from '@remix-run/route-pattern'\n\nimport type { RequestMethod } from './request-methods.ts'\nimport type { Simplify } from './type-utils.ts'\n\n/**\n * A map of route names to `Route` objects or nested `RouteMap` objects.\n */\nexport interface RouteMap<pattern extends string = string> {\n  [name: string]: Route<RequestMethod | 'ANY', pattern> | RouteMap<pattern>\n}\n\n/**\n * A route definition that includes a request method and pattern.\n */\nexport class Route<\n  method extends RequestMethod | 'ANY' = RequestMethod | 'ANY',\n  pattern extends string = string,\n> {\n  /**\n   * The HTTP method this route matches.\n   */\n  readonly method: method | 'ANY'\n\n  /**\n   * The pattern this route matches.\n   */\n  readonly pattern: RoutePattern<pattern>\n\n  /**\n   * @param method The HTTP method this route matches\n   * @param pattern The pattern this route matches\n   */\n  constructor(method: method | 'ANY', pattern: pattern | RoutePattern<pattern>) {\n    this.method = method\n    this.pattern = typeof pattern === 'string' ? new RoutePattern(pattern) : pattern\n  }\n\n  /**\n   * Build a URL href for this route using the given parameters.\n   *\n   * @param args The parameters to use for building the href\n   * @returns The built URL href\n   */\n  href(...args: HrefBuilderArgs<pattern>): string {\n    return this.pattern.href(...args)\n  }\n\n  /**\n   * Match a URL against this route's pattern.\n   *\n   * @param url The URL to match\n   * @returns The match result, or `null` if the URL doesn't match\n   */\n  match(url: string | URL): RouteMatch<pattern> | null {\n    return this.pattern.match(url)\n  }\n}\n\n/**\n * Build a `Route` type from a request method and pattern.\n */\n// prettier-ignore\nexport type BuildRoute<method extends RequestMethod | 'ANY', pattern extends string | RoutePattern> =\n  pattern extends string ? Route<method, pattern> :\n  pattern extends RoutePattern<infer source extends string> ? Route<method, source> :\n  never\n\n/**\n * Create a route map from a set of route definitions.\n *\n * @param defs The route definitions\n * @returns The route map\n */\nexport function createRoutes<const defs extends RouteDefs>(defs: defs): BuildRouteMap<'/', defs>\n/**\n * Create a route map from a set of route definitions with a base pattern.\n *\n * @param base The base pattern for all routes\n * @param defs The route definitions\n * @returns The route map\n */\nexport function createRoutes<base extends string, const defs extends RouteDefs>(\n  base: base | RoutePattern<base>,\n  defs: defs,\n): BuildRouteMap<base, defs>\nexport function createRoutes(baseOrDefs: any, defs?: RouteDefs): RouteMap {\n  return typeof baseOrDefs === 'string' || baseOrDefs instanceof RoutePattern\n    ? buildRouteMap(\n        typeof baseOrDefs === 'string' ? new RoutePattern(baseOrDefs) : baseOrDefs,\n        defs!,\n      )\n    : buildRouteMap(new RoutePattern('/'), baseOrDefs)\n}\n\nfunction buildRouteMap<base extends string, defs extends RouteDefs>(\n  base: RoutePattern<base>,\n  defs: defs,\n): BuildRouteMap<base, defs> {\n  let routes: any = {}\n\n  for (let key in defs) {\n    let def = defs[key]\n\n    if (def instanceof Route) {\n      routes[key] = new Route(def.method, base.join(def.pattern))\n    } else if (typeof def === 'string' || def instanceof RoutePattern) {\n      routes[key] = new Route('ANY', base.join(def))\n    } else if (typeof def === 'object' && def != null && 'pattern' in def) {\n      routes[key] = new Route((def as any).method ?? 'ANY', base.join((def as any).pattern))\n    } else {\n      routes[key] = buildRouteMap(base, def as any)\n    }\n  }\n\n  return routes\n}\n\n// prettier-ignore\nexport type BuildRouteMap<base extends string, defs extends RouteDefs> = Simplify<{\n  -readonly [name in keyof defs]: (\n    defs[name] extends Route<infer method extends RequestMethod | 'ANY', infer pattern extends string> ? Route<method, Join<base, pattern>> :\n    defs[name] extends RouteDef ? BuildRouteWithBase<base, defs[name]> :\n    defs[name] extends RouteDefs ? BuildRouteMap<base, defs[name]> :\n    never\n  )\n}>\n\n// prettier-ignore\ntype BuildRouteWithBase<base extends string, def extends RouteDef> =\n  def extends string ? Route<'ANY', Join<base, def>> :\n  def extends RoutePattern<infer pattern extends string> ? Route<'ANY', Join<base, pattern>> :\n  def extends { method: infer method extends RequestMethod | 'ANY', pattern: infer pattern } ? (\n    pattern extends string ? Route<method, Join<base, pattern>> :\n    pattern extends RoutePattern<infer source extends string> ? Route<method, Join<base, source>> :\n    never\n  ) :\n  never\n\n/**\n * A map of route names to route definitions.\n */\nexport interface RouteDefs {\n  [name: string]: Route | RouteDef | RouteDefs\n}\n\n/**\n * A route definition that can be a string pattern, `RoutePattern`, or an object with method and\n * pattern.\n */\nexport type RouteDef<source extends string = string> =\n  | source\n  | RoutePattern<source>\n  | { method?: RequestMethod; pattern: source | RoutePattern<source> }\n", "import type { RoutePattern } from '@remix-run/route-pattern'\n\nimport { Route } from '../route-map.ts'\n\n/**\n * Shorthand for a DELETE route.\n *\n * @alias del\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for DELETE requests\n */\nexport function createDeleteRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'DELETE', source> {\n  return new Route('DELETE', pattern)\n}\n\n/**\n * Shorthand for a GET route.\n *\n * @alias get\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for GET requests\n */\nexport function createGetRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'GET', source> {\n  return new Route('GET', pattern)\n}\n\n/**\n * Shorthand for a HEAD route.\n *\n * @alias head\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for HEAD requests\n */\nexport function createHeadRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'HEAD', source> {\n  return new Route('HEAD', pattern)\n}\n\n/**\n * Shorthand for a OPTIONS route.\n *\n * @alias options\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for OPTIONS requests\n */\nexport function createOptionsRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'OPTIONS', source> {\n  return new Route('OPTIONS', pattern)\n}\n\n/**\n * Shorthand for a PATCH route.\n *\n * @alias patch\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for PATCH requests\n */\nexport function createPatchRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'PATCH', source> {\n  return new Route('PATCH', pattern)\n}\n\n/**\n * Shorthand for a POST route.\n *\n * @alias post\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for POST requests\n */\nexport function createPostRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'POST', source> {\n  return new Route('POST', pattern)\n}\n\n/**\n * Shorthand for a PUT route.\n *\n * @alias put\n * @param pattern The route pattern string or {@link RoutePattern} object\n * @returns A Route configured for PUT requests\n */\nexport function createPutRoute<source extends string>(\n  pattern: source | RoutePattern<source>,\n): Route<'PUT', source> {\n  return new Route('PUT', pattern)\n}\n", "import type { RoutePattern } from '@remix-run/route-pattern'\n\nimport type { RequestMethod } from '../request-methods.ts'\nimport { createRoutes } from '../route-map.ts'\nimport type { BuildRouteMap } from '../route-map.ts'\n\nexport interface FormOptions {\n  /**\n   * The method the `<form>` uses to submit the action.\n   *\n   * @default 'POST'\n   */\n  formMethod?: RequestMethod\n  /**\n   * Custom names to use for the `index` and `action` routes.\n   */\n  names?: {\n    index?: string\n    action?: string\n  }\n}\n\n/**\n * Create a route map with `index` (`GET`) and `action` (`POST`) routes, suitable\n * for showing a standard HTML `<form>` and handling its submit action at the same\n * URL.\n *\n * @param pattern The route pattern to use for the form and its submit action\n * @param options Options to configure the form action routes\n * @returns The route map with `index` and `action` routes\n */\nexport function createFormRoutes<pattern extends string, const options extends FormOptions>(\n  pattern: pattern | RoutePattern<pattern>,\n  options?: options,\n): BuildFormMap<pattern, options> {\n  let formMethod = options?.formMethod ?? 'POST'\n  let indexName = options?.names?.index ?? 'index'\n  let actionName = options?.names?.action ?? 'action'\n\n  return createRoutes(pattern, {\n    [indexName]: { method: 'GET', pattern: '/' },\n    [actionName]: { method: formMethod, pattern: '/' },\n  }) as BuildFormMap<pattern, options>\n}\n\n// prettier-ignore\ntype BuildFormMap<pattern extends string, options extends FormOptions> = BuildRouteMap<\n  pattern,\n  {\n    [\n      key in options extends { names: { index: infer indexName extends string } } ? indexName : 'index'\n    ]: {\n      method: 'GET'\n      pattern: '/'\n    }\n  } & {\n    [\n      key in options extends { names: { action: infer actionName extends string } } ? actionName : 'action'\n    ]: {\n      method: options extends { formMethod: infer formMethod extends RequestMethod } ? formMethod : 'POST'\n      pattern: '/'\n    }\n  }\n>\n", "import type { RoutePattern } from '@remix-run/route-pattern'\n\nimport { type BuildRouteMap, createRoutes } from '../route-map.ts'\n\nexport type ResourcesMethod = 'index' | 'new' | 'show' | 'create' | 'edit' | 'update' | 'destroy'\n\n// prettier-ignore\nexport const ResourcesMethods = ['index', 'new', 'show', 'create', 'edit', 'update', 'destroy'] as const\n\nexport type ResourcesOptions = {\n  /**\n   * The parameter name to use for the resource.\n   *\n   * @default 'id'\n   */\n  param?: string\n  /**\n   * Custom names to use for the resource routes.\n   */\n  names?: {\n    index?: string\n    new?: string\n    show?: string\n    create?: string\n    edit?: string\n    update?: string\n    destroy?: string\n  }\n} & (\n  | {\n      /**\n       * The resource methods to include in the route map. If not provided, all\n       * methods (`index`, `show`, `new`, `create`, `edit`, `update`, and `destroy`)\n       * will be included.\n       * Cannot be used together with `exclude`.\n       */\n      only?: ResourcesMethod[]\n      exclude?: never\n    }\n  | {\n      /**\n       * The resource methods to exclude from the route map.\n       * Cannot be used together with `only`.\n       */\n      exclude?: ResourcesMethod[]\n      only?: never\n    }\n)\n\n/**\n * Create a route map with standard CRUD routes for a resource collection.\n *\n * @param base The base route pattern to use for the resources\n * @param options Options to configure the resource routes\n * @returns The route map with CRUD routes\n */\nexport function createResourcesRoutes<base extends string, const options extends ResourcesOptions>(\n  base: base | RoutePattern<base>,\n  options?: options,\n): BuildResourcesMap<base, options> {\n  // Runtime validation\n  if (options?.only && options?.exclude) {\n    throw new Error('Cannot specify both \"only\" and \"exclude\" options')\n  }\n\n  // Resolve which methods to include\n  let only: readonly ResourcesMethod[]\n  if (options?.only) {\n    only = options.only\n  } else if (options?.exclude) {\n    only = ResourcesMethods.filter((m) => !options.exclude!.includes(m))\n  } else {\n    only = ResourcesMethods\n  }\n\n  let param = options?.param ?? 'id'\n  let indexName = options?.names?.index ?? 'index'\n  let newName = options?.names?.new ?? 'new'\n  let showName = options?.names?.show ?? 'show'\n  let createName = options?.names?.create ?? 'create'\n  let editName = options?.names?.edit ?? 'edit'\n  let updateName = options?.names?.update ?? 'update'\n  let destroyName = options?.names?.destroy ?? 'destroy'\n\n  let routes: any = {}\n\n  if (only.includes('index')) {\n    routes[indexName] = { method: 'GET', pattern: `/` }\n  }\n  if (only.includes('new')) {\n    routes[newName] = { method: 'GET', pattern: `/new` }\n  }\n  if (only.includes('show')) {\n    routes[showName] = { method: 'GET', pattern: `/:${param}` }\n  }\n  if (only.includes('create')) {\n    routes[createName] = { method: 'POST', pattern: `/` }\n  }\n  if (only.includes('edit')) {\n    routes[editName] = { method: 'GET', pattern: `/:${param}/edit` }\n  }\n  if (only.includes('update')) {\n    routes[updateName] = { method: 'PUT', pattern: `/:${param}` }\n  }\n  if (only.includes('destroy')) {\n    routes[destroyName] = { method: 'DELETE', pattern: `/:${param}` }\n  }\n\n  return createRoutes(base, routes) as BuildResourcesMap<base, options>\n}\n\ntype BuildResourcesMap<base extends string, options extends ResourcesOptions> = BuildRouteMap<\n  base,\n  BuildResourcesRoutes<\n    options,\n    options extends { only: readonly ResourcesMethod[] }\n      ? options['only'][number]\n      : options extends { exclude: readonly ResourcesMethod[] }\n        ? Exclude<ResourcesMethod, options['exclude'][number]>\n        : ResourcesMethod,\n    GetParam<options>\n  >\n>\n\n// prettier-ignore\ntype BuildResourcesRoutes<\n  options extends ResourcesOptions,\n  method extends ResourcesMethod,\n  param extends string,\n> = {\n  [methodName in method as GetResourcesRouteName<options, methodName>]: ResourcesRoutes<param>[methodName]\n}\n\ntype GetResourcesRouteName<\n  options extends ResourcesOptions,\n  method extends ResourcesMethod,\n> = method extends ResourcesMethod\n  ? options extends { names: { [methodName in method]: infer customName extends string } }\n    ? customName\n    : method\n  : never\n\ntype ResourcesRoutes<param extends string> = {\n  index: { method: 'GET'; pattern: `/` }\n  new: { method: 'GET'; pattern: `/new` }\n  show: { method: 'GET'; pattern: `/:${param}` }\n  create: { method: 'POST'; pattern: `/` }\n  edit: { method: 'GET'; pattern: `/:${param}/edit` }\n  update: { method: 'PUT'; pattern: `/:${param}` }\n  destroy: { method: 'DELETE'; pattern: `/:${param}` }\n}\n\n// prettier-ignore\ntype GetParam<options extends ResourcesOptions> =\n  options extends { param: infer param extends string } ? param : 'id'\n", "import { form, get, post, resources, route } from '@remix-run/fetch-router'\n\nexport const routes = route({\n  assets: get('/assets/*path'),\n  uploads: get('/uploads/*key'),\n  playground: get('/playground'),\n\n  account: route('/account', {}),\n\n  auth: {\n    login: form('/login'),\n    logout: post('/logout'),\n    register: form('/register'),\n    forgotPassword: form('/forgot-password'),\n    resetPassword: form('reset-password/:token'),\n\n    providers: route('/providers', {\n      google: route('/google', {\n        login: get('/login'),\n        callback: get('/callback'),\n      }),\n    }),\n  },\n\n  admin: route('/admin', {\n    search: get('/search'),\n    stores: resources('/stores', { param: 'storeId' }),\n\n    suppliers: route('/suppliers', {\n      export: get('/export'),\n      ...resources('/', { param: 'supplierId' }),\n    }),\n\n    orders: route('/orders', {\n      index: get('/'),\n      summary: get('/summary'),\n      items: route('/items', {\n        export: get('/export'),\n        ...resources('/', { param: 'orderId' }),\n      }),\n    }),\n\n    dashboard: route('/dashboard', {\n      index: get('/'),\n      summary: get('/summary'),\n      salesAndPurchases: get('/sales-purchases'),\n      stock: route('/stock', {\n        topSelling: get('/top-selling'),\n        lowQuantity: get('/low-quantity'),\n      }),\n    }),\n\n    report: route('/report', {\n      index: get('/'),\n      profitAndRevenue: get('/profit-revenue'),\n      bestselling: route('/bestselling', {\n        category: get('/category'),\n        product: get('/product'),\n      }),\n    }),\n\n    inventory: route('/inventory', {\n      index: get('/'),\n      summary: get('summary'),\n      products: route('/product', {\n        ...resources('/', { exclude: ['show'], param: 'productId' }),\n        export: get('/export'),\n        show: {\n          ...route('/:productId', {\n            overview: get('/overview'),\n            adjustments: get('/adjustments'),\n            history: get('/history'),\n            download: get('/download'),\n          }),\n        },\n      }),\n    }),\n  }),\n})\n", null],
  "mappings": "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",
  "names": ["RequestBodyMethods", "RequestMethods", "split", "source", "protocol", "hostname", "port", "pathname", "search", "searchStart", "index", "solidusIndex", "hostEndIndex", "colonIndex", "isPort", "i", "char", "parseSearchConstraints", "search", "constraints", "part", "eqIndex", "name", "decodeSearchComponent", "valuePart", "existing", "decodedValue", "parseSearch", "namesWithoutAssignment", "namesWithAssignment", "valuesByKey", "value", "set", "text", "ParseError", "description", "partName", "source", "position", "parse", "protocol", "hostname", "port", "pathname", "search", "searchConstraints", "ranges", "split", "parsePart", "parseSearchConstraints", "identifierMatcher", "sep", "start", "end", "tokens", "currentTokens", "tokensStack", "openIndexes", "appendText", "text", "lastToken", "i", "char", "remaining", "name", "next", "MissingParamError", "paramName", "formatHref", "parsed", "params", "searchParams", "href", "protocol", "resolveTokens", "hostname", "port", "pathname", "urlSearchParams", "filteredParams", "key", "value", "search", "tokens", "sep", "str", "token", "name", "MissingParamError", "error", "stringify", "parsed", "str", "protocol", "stringifyTokens", "hostname", "port", "pathname", "startsWithSeparator", "search", "stringifySearchConstraints", "tokens", "firstToken", "sep", "i", "token", "parts", "key", "value", "requiredValue", "join", "a", "b", "protocol", "hostname", "port", "pathname", "joinPathnames", "searchConstraints", "joinSearchConstraints", "stringify", "tokens", "inputStartsWithSeparator", "startsWithSeparator", "baseSearch", "inputSearch", "merged", "key", "inputConstraint", "baseConstraint", "mergedConstraint", "RoutePattern", "_RoutePattern", "#parsed", "#compiled", "source", "options", "parse", "args", "formatHref", "input", "parsedInput", "join", "url", "matchOrigin", "matcher", "paramNames", "#compile", "pathname", "match", "params", "i", "paramName", "matchSearch", "compilePattern", "parsed", "ignoreCase", "protocol", "hostname", "port", "protocolSource", "tokensToRegExpSource", "hostnameSource", "portSource", "regexpEscape", "pathnameSource", "tokens", "sep", "paramRegExpSource", "forceLowerCase", "token", "text", "search", "constraints", "namesWithoutAssignment", "namesWithAssignment", "valuesByKey", "parseSearch", "key", "constraint", "hasAssigned", "hasBare", "values", "value", "Route", "method", "pattern", "RoutePattern", "args", "url", "createRoutes", "baseOrDefs", "defs", "buildRouteMap", "base", "routes", "key", "def", "createGetRoute", "pattern", "Route", "createPostRoute", "pattern", "Route", "createFormRoutes", "pattern", "options", "formMethod", "indexName", "actionName", "createRoutes", "ResourcesMethods", "createResourcesRoutes", "base", "options", "only", "param", "indexName", "newName", "showName", "createName", "editName", "updateName", "destroyName", "routes", "createRoutes", "routes", "createRoutes", "createGetRoute", "createFormRoutes", "createPostRoute", "createResourcesRoutes", "jsx", "type", "props", "key", "jsxAdapter", "jsxs", "jsxAdapter", "type", "props", "key", "createElement"]
}
